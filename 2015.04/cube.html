<html>
  <head>
    <title>IBM Ponder This 03/2015 Solution</title>
    <style>
      body { margin: 0; }
      canvas { width: 100%; height: 100% }
    </style>
  </head>
  <body>
    <script src="js/three.min.js"></script>
    <script src="js/stats.min.js"></script>
    <script src="js/CanvasRenderer.js"></script>
    <script src="js/Projector.js"></script>
    <script>
      // check WebGL availability
      function webglAvailable() {
        try {
          var canvas = document.createElement( 'canvas' );
          return !!( window.WebGLRenderingContext && (
            canvas.getContext( 'webgl' ) ||
            canvas.getContext( 'experimental-webgl' ) )
          );
        } catch ( e ) {
          return false;
        }
      }

      function init() {
        if ( webglAvailable() ) {
          renderer = new THREE.WebGLRenderer({antialias:true});
        } else {
          renderer = new THREE.CanvasRenderer();
        }

        renderer.setPixelRatio( window.devicePixelRatio );
        scene = new THREE.Scene();
        var w = window.innerWidth;
        var h = window.innerHeight;
        //var camera = new THREE.PerspectiveCamera( 75, w/h, 0.1, 1000 );
        camera = new THREE.OrthographicCamera( w / -100, w / 100, h / 100, h / -100, 1, 1000 );
        camera.position.z = 10;

        renderer.setSize( w, h );
        document.body.appendChild( renderer.domElement );

        stats = new Stats();
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.top = '0px';
        document.body.appendChild( stats.domElement );


        /*var geometry = new THREE.Geometry();

        function point(character, index) {
          var x = Math.floor((index % 49) % 7);
          var y = Math.floor(index / 49);
          var z = Math.floor((index % 49) / 7);
          vertex = new THREE.Vector3( x - 3, y - 3, z - 3 );
          geometry.vertices.push(vertex);
          geometry.colors.push(new THREE.Color( character == "W" ? 0xff0000 : 0x00ff00 ));
        };*/


        var PI2 = Math.PI * 2;
        var program = function ( context ) {

          context.beginPath();
          context.arc( 0, 0, 0.5, 0, PI2, true );
          context.fill();

        }

        group = new THREE.Group();
        scene.add( group );

        var cube =  "WWWWWWWWWWWWWWWPPPPPWWPPPPPWWWWWWWWWPPPPPWWWWWWWWWPPPPPWWPPPPPWWPPPPPWWPPPPPWWPPPPPWWPPPPPWWWWWWWWWWWWWWWWPPPPPWWPPPPPWWWPPPWWWPPPPPWWPPPPPWWPPPPPWWWWWWWWWPPPPPWWPPPPPWPPPWPPPWPPPPPWWPPPPPWWWWWWWWWPPPPPWWPPPPPWWPPPPPWWPPPPPWWPPPPPWWPPPPPWWWWWWWWWWWWWWWWPPPPPWWPPPPPWWPWPWPWWPPPPPWWPPPPPWWPPPPPWWWWWWWWWPPPPPWWWWWWWWWPPPPPWWPPPPPWWWWWWWWWWWWWWW";
        for ( el = 0; el < cube.length; ++el ) {
          //point(cube[el], el);

          var material = new THREE.SpriteCanvasMaterial( {
            color: Math.random() * 0x808008 + 0x808080,
            program: program
          } );

          particle = new THREE.Sprite( material );
          particle.position.x = Math.random() * 2 - 1;
          particle.position.y = Math.random() * 2 - 1;
          particle.position.z = Math.random() * 2 - 1;
          particle.scale.x = particle.scale.y = 0.1;
          group.add( particle );
        }
        /*geometry.computeBoundingBox();

        var material = new THREE.PointCloudMaterial({size: 0.1, vertexColors: THREE.VertexColors});
        var cloud = new THREE.PointCloud( geometry, material );
        scene.add( cloud );*/



        addMouseHandler();
      }


      var mouseDown = false,
        mouseX = 0,
        mouseY = 0;

      function onMouseMove(evt) {
          if (!mouseDown) {
              return;
          }

          evt.preventDefault();

          var deltaX = evt.clientX - mouseX,
              deltaY = evt.clientY - mouseY;
          mouseX = evt.clientX;
          mouseY = evt.clientY;
          rotateScene(deltaX, deltaY);
      }

      function onMouseDown(evt) {
          evt.preventDefault();

          mouseDown = true;
          mouseX = evt.clientX;
          mouseY = evt.clientY;
      }

      function onMouseUp(evt) {
          evt.preventDefault();

          mouseDown = false;
      }

      function addMouseHandler() {
        document.addEventListener('mousemove', onMouseMove, false);
        document.addEventListener('mousedown', onMouseDown, false);
        document.addEventListener('mouseup', onMouseUp, false);
      }

      function rotateScene(deltaX, deltaY) {
      group.rotation.y += deltaX / 100;
      group.rotation.x += deltaY / 100;
  }


      var render = function () {
        requestAnimationFrame( render );

        //cloud.rotation.x += 0.001;
        //cloud.rotation.y += 0.001;

        renderer.render(scene, camera);
        stats.update();
      };

      init();
      render();























      /*var container, stats;
      var camera, scene, renderer, group, particle;
      var mouseX = 0, mouseY = 0;

      var windowHalfX = window.innerWidth / 2;
      var windowHalfY = window.innerHeight / 2;

      init();
      animate();

      function init() {

        container = document.createElement( 'div' );
        document.body.appendChild( container );

        camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 3000 );
        camera.position.z = 1000;

        scene = new THREE.Scene();

        var PI2 = Math.PI * 2;
        var program = function ( context ) {

          context.beginPath();
          context.arc( 0, 0, 0.5, 0, PI2, true );
          context.fill();

        }

        group = new THREE.Group();
        scene.add( group );

        for ( var i = 0; i < 1000; i++ ) {

          var material = new THREE.SpriteCanvasMaterial( {
            color: Math.random() * 0x808008 + 0x808080,
            program: program
          } );

          particle = new THREE.Sprite( material );
          particle.position.x = Math.random() * 2000 - 1000;
          particle.position.y = Math.random() * 2000 - 1000;
          particle.position.z = Math.random() * 2000 - 1000;
          particle.scale.x = particle.scale.y = Math.random() * 20 + 10;
          group.add( particle );
        }

        renderer = new THREE.CanvasRenderer();
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        container.appendChild( renderer.domElement );

        stats = new Stats();
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.top = '0px';
        container.appendChild( stats.domElement );

        document.addEventListener( 'mousemove', onDocumentMouseMove, false );
        document.addEventListener( 'touchstart', onDocumentTouchStart, false );
        document.addEventListener( 'touchmove', onDocumentTouchMove, false );

        //

        window.addEventListener( 'resize', onWindowResize, false );

      }

      function onWindowResize() {

        windowHalfX = window.innerWidth / 2;
        windowHalfY = window.innerHeight / 2;

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

      }

      //

      function onDocumentMouseMove( event ) {

        mouseX = event.clientX - windowHalfX;
        mouseY = event.clientY - windowHalfY;
      }

      function onDocumentTouchStart( event ) {

        if ( event.touches.length === 1 ) {

          event.preventDefault();

          mouseX = event.touches[ 0 ].pageX - windowHalfX;
          mouseY = event.touches[ 0 ].pageY - windowHalfY;

        }

      }

      function onDocumentTouchMove( event ) {

        if ( event.touches.length === 1 ) {

          event.preventDefault();

          mouseX = event.touches[ 0 ].pageX - windowHalfX;
          mouseY = event.touches[ 0 ].pageY - windowHalfY;

        }

      }

      //

      function animate() {

        requestAnimationFrame( animate );

        render();
        stats.update();

      }

      function render() {

        camera.position.x += ( mouseX - camera.position.x ) * 0.05;
        camera.position.y += ( - mouseY - camera.position.y ) * 0.05;
        camera.lookAt( scene.position );

        group.rotation.x += 0.01;
        group.rotation.y += 0.02;

        renderer.render( scene, camera );

      }*/

    
    </script>
  </body>
</html>